{"ast":null,"code":"!function (t, s) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? s(exports) : \"function\" == typeof define && define.amd ? define([\"exports\"], s) : s((t = \"undefined\" != typeof globalThis ? globalThis : t || self).t = {});\n}(this, function (t) {\n  \"use strict\";\n\n  class s {\n    constructor(t, s, i) {\n      let e = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : t << 16 | s << 8 | i;\n      this.i = 1, this.h = -1, this.o = -1, this.u = -1, this.l = -1, this.g = t, this.M = s, this.p = i, this.m = e;\n    }\n    static distance(t, s) {\n      return (Math.abs(s.g - t.g) + Math.abs(s.M - t.M) + Math.abs(s.p - t.p)) / 765;\n    }\n    v() {\n      const t = this.g / 255,\n        s = this.M / 255,\n        i = this.p / 255,\n        e = Math.max(t, s, i),\n        n = Math.min(t, s, i);\n      if (this.u = (e + n) / 2, e === n) this.o = 0, this.h = 0, this.l = 0;else {\n        const r = e - n;\n        switch (this.h = this.u > .5 ? r / (2 - e - n) : r / (e + n), this.l = this.h * (2 * (.5 - Math.abs(.5 - this.u))), e) {\n          case t:\n            this.o = ((s - i) / r + (s < i ? 6 : 0)) / 6;\n            break;\n          case s:\n            this.o = ((i - t) / r + 2) / 6;\n            break;\n          case i:\n            this.o = ((t - s) / r + 4) / 6;\n        }\n      }\n    }\n    get C() {\n      return -1 === this.o && this.v(), this.o;\n    }\n    get $() {\n      return -1 === this.h && this.v(), this.h;\n    }\n    get _() {\n      return -1 === this.u && this.v(), this.u;\n    }\n    get j() {\n      return -1 === this.l && this.v(), this.l;\n    }\n  }\n  const i = (t, s) => Math.abs(t - s);\n  class e {\n    constructor() {\n      this.D = [], this.N = null;\n    }\n    O(t) {\n      this.D.push(t), this.N = null;\n    }\n    P(t, s, e, n) {\n      for (let o = 0; o < this.D.length; o++) {\n        const a = this.D[o];\n        if (!(r = a.C, h = t.C, Math.min(i(r, h), i((r + .5) % 1, (h + .5) % 1)) < s && i(a.$, t.$) < e && i(a._, t._) < n)) return !1;\n      }\n      var r, h;\n      return !0;\n    }\n    get W() {\n      if (!this.N) {\n        const {\n            r: t,\n            G: i,\n            b: e\n          } = this.D.reduce((t, s) => (t.r += s.g, t.G += s.M, t.b += s.p, t), {\n            r: 0,\n            G: 0,\n            b: 0\n          }),\n          n = this.D.reduce((t, s) => t + s.i, 0);\n        this.N = new s(Math.round(t / this.D.length), Math.round(i / this.D.length), Math.round(e / this.D.length)), this.N.i = n;\n      }\n      return this.N;\n    }\n  }\n  class n {\n    constructor(t, s, i) {\n      this.I = [], this.C = t, this.$ = s, this._ = i;\n    }\n    O(t) {\n      const s = this.I.find(s => s.P(t, this.C, this.$, this._));\n      if (s) s.O(t);else {\n        const s = new e();\n        s.O(t), this.I.push(s);\n      }\n    }\n    L() {\n      return this.I.map(t => t.W);\n    }\n  }\n  const r = function (t, s) {\n      let i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      let e = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Number.MAX_SAFE_INTEGER;\n      if (!Number.isInteger(s) || s < i || s > e) throw new Error(`${t} is invalid (${s})`);\n      return s;\n    },\n    h = function (t, s) {\n      let i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      let e = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Number.MAX_VALUE;\n      if (Number(s) !== s || s < i || s > e) throw new Error(`${t} is invalid (${s})`);\n      return s;\n    },\n    o = (t, s) => {\n      if (!s || \"[object Function]\" !== {}.toString.call(s)) throw new Error(`${t} is invalid (${s})`);\n      return s;\n    };\n  var a = t => {\n    var s, i, e, n, a, u, c, l;\n    return [r(\"pixels\", null != (s = t.pixels) ? s : 1e4, 1), h(\"distance\", null != (i = t.distance) ? i : .12, 0, 1), r(\"splitPower\", null != (e = t.splitPower) ? e : 10, 2, 15), o(\"colorValidator\", null != (n = t.colorValidator) ? n : (t, s, i, e) => (null != e ? e : 255) > 250), h(\"hueDistance\", null != (a = t.hueDistance) ? a : .08333333333333333, 0, 1), h(\"saturationDistance\", null != (u = t.saturationDistance) ? u : .2, 0, 1), h(\"lightnessDistance\", null != (c = t.lightnessDistance) ? c : .2, 0, 1), null != (l = t.crossOrigin) ? l : null];\n  };\n  class u {\n    constructor() {\n      this.i = 1, this.S = {};\n    }\n    O(t, i, e, n) {\n      return this.S[t] ? this.S[t].i++ : this.S[t] = new s(i, e, n, t), this.S[t];\n    }\n    k() {\n      return Object.keys(this.S).map(t => this.S[t]);\n    }\n    T(t) {\n      if (void 0 === this.B) {\n        const s = this.k().map(s => s.i / t);\n        s.sort((t, s) => s - t), this.B = s[0] || 0;\n      }\n      return this.B;\n    }\n    F(t) {\n      const s = this.k();\n      return s.sort((s, i) => i.i / t - s.i / t), s[0];\n    }\n    H() {\n      return this.k().reduce((t, s) => t.i >= s.i ? t : s);\n    }\n  }\n  class c {\n    constructor() {\n      this.i = 1, this.S = {};\n    }\n    R(t) {\n      return this.S[t] ? this.S[t].i++ : this.S[t] = new c(), this.S[t];\n    }\n    k() {\n      return Object.keys(this.S).map(t => this.S[t]);\n    }\n    V(t) {\n      return this.S[t] ? this.S[t].i++ : this.S[t] = new u(), this.S[t];\n    }\n    T(t) {\n      if (void 0 === this.B) {\n        const s = this.k().map(s => s.i / t);\n        s.sort((t, s) => s - t), this.B = s[0] || 0;\n      }\n      return this.B;\n    }\n    F(t) {\n      const s = this.k();\n      return s.sort((s, i) => i.i / t - s.i / t), s[0].F(t);\n    }\n    H() {\n      return this.k().reduce((t, s) => t.H().i >= s.H().i ? t : s).H();\n    }\n    q(t, i) {\n      const e = this.k().map(t => {\n        const {\n            i: s\n          } = t,\n          i = t.H();\n        return i.i = s, i;\n      });\n      e.sort((t, s) => s.i / i - t.i / i);\n      const n = [];\n      return e.forEach(i => {\n        const e = n.find(e => s.distance(e, i) < t);\n        e ? e.i += i.i : n.push(i);\n      }), n;\n    }\n  }\n  var l = (_ref, e, n, r, h) => {\n    let {\n      data: t,\n      width: s,\n      height: i\n    } = _ref;\n    const o = new c(),\n      a = s && i && Math.floor(s * i / e) || 1;\n    for (let u = 0; u < t.length; u += 4 * a) {\n      const s = t[u],\n        i = t[u + 1],\n        e = t[u + 2];\n      if (h(s, i, e, t[u + 3])) {\n        const t = s << 16 | i << 8 | e,\n          n = (s >> 4 & 15) << 8 | (i >> 4 & 15) << 4 | e >> 4 & 15,\n          h = Math.round(s * (r - 1) / 255) * (r * r) + Math.round(i * (r - 1) / 255) * r + Math.round(e * (r - 1) / 255);\n        o.R(h).V(n).O(t, s, i, e);\n      }\n    }\n    return o.q(n, e);\n  };\n  const d = (t, s, i, e, r) => {\n      const h = ((t, s, i, e, r) => {\n        const h = new n(i, e, r);\n        t.forEach(t => h.O(t));\n        const o = h.L();\n        return o.sort((t, i) => (i.j + .1) * (.9 - i.i / s) - (t.j + .1) * (.9 - t.i / s)), o;\n      })(t, s, i, e, r);\n      return h.map(t => ((t, s) => ({\n        hex: `#${\"0\".repeat(6 - t.m.toString(16).length)}${t.m.toString(16)}`,\n        red: t.g,\n        green: t.M,\n        blue: t.p,\n        area: t.i / s,\n        hue: t.C,\n        saturation: t.$,\n        lightness: t._,\n        intensity: t.j\n      }))(t, s));\n    },\n    f = function (t) {\n      let s = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      const [i, e, n, r, h, o, u] = a(s),\n        c = l(t, i, e, n, r),\n        f = t.width && t.height ? Math.min(t.width * t.height, i) : i;\n      return d(c, f, h, o, u);\n    },\n    g = function (t) {\n      let s = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      const [i, e, n, r, h, o, u, c] = a(s);\n      return t.crossOrigin = c, new Promise(s => {\n        const a = t => {\n          const a = ((t, s) => {\n              const i = t.width * t.height,\n                e = i < s ? t.width : Math.round(t.width * Math.sqrt(s / i)),\n                n = i < s ? t.height : Math.round(t.height * Math.sqrt(s / i)),\n                r = document.createElement(\"canvas\");\n              r.width = e, r.height = n;\n              const h = r.getContext(\"2d\");\n              return h.drawImage(t, 0, 0, t.width, t.height, 0, 0, e, n), h.getImageData(0, 0, e, n);\n            })(t, i),\n            c = l(a, i, e, n, r);\n          s(d(c, i, h, o, u));\n        };\n        if (t.complete) a(t);else {\n          const s = () => {\n            t.removeEventListener(\"load\", s), a(t);\n          };\n          t.addEventListener(\"load\", s);\n        }\n      });\n    },\n    M = function (t) {\n      let s = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      const i = new Image();\n      return i.src = t, g(i, s);\n    },\n    w = (t, s) => {\n      if (t instanceof Image) return g(t, s);\n      if (t instanceof ImageData || t instanceof Object && t.data) return new Promise(i => {\n        i(f(t, s));\n      });\n      if (\"string\" == typeof t) return M(t, s);\n      throw new Error(\"Can not analyse picture\");\n    };\n  t.default = w, t.extractColors = w, t.extractColorsFromImage = g, t.extractColorsFromImageData = f, t.extractColorsFromSrc = M, Object.defineProperties(t, {\n    A: {\n      value: !0\n    },\n    [Symbol.toStringTag]: {\n      value: \"Module\"\n    }\n  });\n});","map":{"version":3,"mappings":"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","names":["Color","constructor","red","green","blue","hex","this","__saturation","__hue","__lightness","__intensity","_red","_green","_blue","_hex","static","colorA","colorB","abs","Math","updateHSL","max","min","distance","_hue","_saturation","_lightness","_intensity","a","b","AverageGroup","_average","addColor","color","push","isSamePalette","hue","saturation","lightness","i","colors","length","currentColor","average","r","G","reduce","total","g","_count","round","AverageManager","_groups","samePalette","find","averageGroup","getGroups","map","testUint","label","val","MAX_SAFE_INTEGER","Number","isInteger","Error","testNumber","MAX_VALUE","testFunction","toString","call","options","pixels","_a","_b","splitPower","_c","_d","_alpha","hueDistance","_e","saturationDistance","_f","lightnessDistance","_g","crossOrigin","_h","BudGroup","_children","getList","keys","key","getMaxWeight","_maxWeight","child","list","sort","getMaxWeightColor","getMaxCountColor","RootGroup","addRootGroup","addBudGroup","getColors","_distance","newList","col","near","_pixels","_splitPower","_colorValidator","data","width","height","reducer","floor","real","medium","small","rootGroup","sortFinalColors","_colors","_hueDistance","_saturationDistance","_lightnessDistance","averageManager","forEach","sorted","repeat","area","intensity","extractColorsFromImageData","imageData","cleanInputs","extractor","px","extractColorsFromImage","image","_crossOrigin","Promise","resolve","_image","currentPixels","sqrt","canvas","document","createElement","getContext","context","getImageData","complete","extract","imageLoaded","extractColorsFromSrc","src","Image","extractColors","picture","ImageData","Object","t","A","value"],"sources":["C:\\Users\\natha\\Desktop\\react-pokedex\\react-pokedex\\node_modules\\extract-colors\\src\\color\\Color.ts","C:\\Users\\natha\\Desktop\\react-pokedex\\react-pokedex\\node_modules\\extract-colors\\src\\sort\\AverageGroup.ts","C:\\Users\\natha\\Desktop\\react-pokedex\\react-pokedex\\node_modules\\extract-colors\\src\\sort\\AverageManager.ts","C:\\Users\\natha\\Desktop\\react-pokedex\\react-pokedex\\node_modules\\extract-colors\\src\\color\\FinalColor.ts","C:\\Users\\natha\\Desktop\\react-pokedex\\react-pokedex\\node_modules\\extract-colors\\src\\extract\\cleanInputs.ts","C:\\Users\\natha\\Desktop\\react-pokedex\\react-pokedex\\node_modules\\extract-colors\\src\\color\\BudGroup.ts","C:\\Users\\natha\\Desktop\\react-pokedex\\react-pokedex\\node_modules\\extract-colors\\src\\color\\RootGroup.ts","C:\\Users\\natha\\Desktop\\react-pokedex\\react-pokedex\\node_modules\\extract-colors\\src\\extract\\extractor.ts","C:\\Users\\natha\\Desktop\\react-pokedex\\react-pokedex\\node_modules\\extract-colors\\src\\extractColors.ts","C:\\Users\\natha\\Desktop\\react-pokedex\\react-pokedex\\node_modules\\extract-colors\\src\\sort\\sortColors.ts","C:\\Users\\natha\\Desktop\\react-pokedex\\react-pokedex\\node_modules\\extract-colors\\src\\extractColors.browser.ts"],"sourcesContent":["/**\n * Informations like saturation or count of pixels in image.\n * \n * @class\n * @classdesc Calculate some informations and store data about color.\n */\nexport default class Color {\n  \n  _red: number\n  _green: number\n  _blue: number\n  _hex: number\n  _count = 1\n\n  private __saturation = -1\n  private __hue = -1\n  private __lightness = -1\n  private __intensity = -1\n\n  /**\n   * Set red, green and blue colors to create the Color object.\n   */\n  constructor (red: number, green: number, blue: number, hex = red << 16 | green << 8 | blue) {\n\n    this._red = red\n    this._green = green\n    this._blue = blue\n    this._hex = hex\n  }\n\n  /**\n   * Distance between two colors.\n   * - Minimum is 0 (between two same colors)\n   * - Maximum is 1 (for example between black and white)\n   */\n  static distance (colorA: Color, colorB: Color) {\n    return (Math.abs(colorB._red - colorA._red) + Math.abs(colorB._green - colorA._green) + Math.abs(colorB._blue - colorA._blue)) / (3 * 0xFF)\n  }  \n\n  updateHSL () {\n    const red = this._red / 255\n    const green = this._green / 255\n    const blue = this._blue / 255\n\n    const max = Math.max(red, green, blue)\n    const min = Math.min(red, green, blue)\n\n    this.__lightness = (max + min) / 2\n\n    // achromatic\n    if (max === min) {\n      this.__hue = 0\n      this.__saturation = 0\n      this.__intensity = 0\n    } else {\n      const distance = max - min;\n      \n      this.__saturation = this.__lightness > 0.5 ? distance / (2 - max - min) : distance / (max + min)\n      this.__intensity = this.__saturation * ((0.5 - Math.abs(0.5 - this.__lightness)) * 2)\n      switch (max) {\n        case red:\n          this.__hue = ((green - blue) / distance + (green < blue ? 6 : 0)) / 6\n          break;\n        case green:\n          this.__hue = ((blue - red) / distance + 2) / 6\n          break;\n        case blue:\n          this.__hue = ((red - green) / distance + 4) / 6\n          break;\n      }\n    }\n\n  }\n\n  /**\n   * Hue from 0 to 1\n   */\n  get _hue () {\n    if (this.__hue === -1) {\n      this.updateHSL()\n    }\n    return this.__hue\n  }\n\n  /**\n   * Saturation from 0 to 1\n   */\n  get _saturation () {\n    if (this.__saturation === -1) {\n      this.updateHSL()\n    }\n    return this.__saturation\n  }\n\n  /**\n   * Lightness from 0 to 1\n   */\n  get _lightness () {\n    if (this.__lightness === -1) {\n      this.updateHSL()\n    }\n    return this.__lightness\n  }\n  \n  /**\n   * Color intensity from 0 to 1\n   */\n  get _intensity () {\n    if (this.__intensity === -1) {\n      this.updateHSL()\n    }\n    return this.__intensity\n  }\n}\n","import Color from \"../color/Color\";\n\nconst distance = (a: number, b: number) => Math.abs(a - b)\nconst hueDistance = (a: number, b: number) =>\n  Math.min(distance(a, b), distance((a + 0.5) % 1, (b + 0.5) % 1))\n\nexport class AverageGroup {\n  colors: Color[] = []\n  private _average: Color | null = null\n\n  addColor(color: Color) {\n    this.colors.push(color)\n    this._average = null\n  }\n\n  isSamePalette(color: Color, hue: number, saturation: number, lightness: number) {\n    for (let i = 0; i < this.colors.length; i++) {\n      const currentColor = this.colors[i]\n      const isSame = \n        hueDistance(currentColor._hue, color._hue) < hue &&\n        distance(currentColor._saturation, color._saturation) < saturation &&\n        distance(currentColor._lightness, color._lightness) < lightness\n\n      if (!isSame) {\n        return false\n      }\n    }\n    return true\n  }\n\n  get average () {\n    if (!this._average) {\n      const { r, g, b } = this.colors.reduce((total, color) => {\n        total.r += color._red\n        total.g += color._green\n        total.b += color._blue\n        return total\n      }, { r: 0, g: 0, b: 0 })\n\n      const total = this.colors.reduce((_count, color) => _count + color._count, 0)\n      this._average = new Color(\n        Math.round(r / this.colors.length),\n        Math.round(g / this.colors.length),\n        Math.round(b / this.colors.length)\n      )\n      this._average._count = total\n    }\n    return this._average\n  } \n}","import Color from \"../color/Color\";\nimport { AverageGroup } from \"./AverageGroup\";\n\n\nexport class AverageManager {\n\n  _hue:number\n  _saturation:number\n  _lightness:number\n\n  private _groups: AverageGroup[] = []\n\n  constructor (\n    hue: number,\n    saturation: number,\n    lightness: number\n  ) {\n    this._hue = hue\n    this._saturation = saturation\n    this._lightness = lightness\n  }\n\n  addColor(color: Color) {\n    const samePalette = this._groups.find(averageGroup => averageGroup.isSamePalette(color, this._hue, this._saturation, this._lightness))\n    if (samePalette) {\n      samePalette.addColor(color)\n    } else {\n      const averageGroup = new AverageGroup()\n      averageGroup.addColor(color)\n      this._groups.push(averageGroup)\n    }\n  }\n\n  getGroups() {\n    return this._groups.map(averageGroup => averageGroup.average)\n  }\n}","import { FinalColor } from \"../types/Color\";\nimport Color from \"./Color\";\n\nexport const createFinalColor = (color: Color, pixels: number): FinalColor => {\n  return {\n    hex: `#${'0'.repeat(6 - color._hex.toString(16).length)}${color._hex.toString(16)}`,\n    red: color._red,\n    green: color._green,\n    blue: color._blue,\n    area: color._count / pixels,\n    hue: color._hue,\n    saturation: color._saturation,\n    lightness: color._lightness,\n    intensity: color._intensity,\n  }\n}","import { BrowserOptions, NodeOptions } from \"../types/Options\"\n\n/**\n * Default extractor values\n */\nexport const enum EXTRACTOR_DEFAULT {\n  PIXELS = 10000,\n  DISTANCE = 0.12,\n  SPLIT_POWER = 10\n}\n\n/**\n * Default average values\n */\nexport const enum AVERAGE_DEFAULT {\n  HUE = 1/12,\n  SATURATION = 1/5,\n  LIGHTNESS = 1/5,\n}\n\n/**\n * Test if value is an integer.\n */\nconst testUint = <T = number>(label: string, val: T, min = 0, max = Number.MAX_SAFE_INTEGER) => {\n  if (!Number.isInteger(val) || val < min || val > max) {\n    throw new Error(`${label} is invalid (${ val })`)\n  }\n\n  return val\n}\n\n/**\n * Test if value is a number.\n */\nconst testNumber = <T = number>(label: string, val: T, min = 0, max = Number.MAX_VALUE) => {\n  if (Number(val) !== val || val < min || val > max) {\n    throw new Error(`${label} is invalid (${ val })`)\n  }\n\n  return val\n}\n\n/**\n * Test if value is a function.\n */\nconst testFunction = <T = () => void>(label: string, val: T) => {\n  if (!val || {}.toString.call(val) !== '[object Function]') {\n    throw new Error(`${label} is invalid (${ val })`)\n  }\n\n  return val\n}\n\nexport default (options:BrowserOptions | NodeOptions): [\n  number,\n  number,\n  number,\n  (red: number, green: number, blue: number, alpha: number) => boolean,\n  number,\n  number,\n  number,\n  \"\" | \"anonymous\" | \"use-credentials\" | null,\n] => {\n  return [\n    testUint('pixels', options.pixels ?? EXTRACTOR_DEFAULT.PIXELS, 1),\n    testNumber('distance', options.distance ?? EXTRACTOR_DEFAULT.DISTANCE, 0, 1),\n    testUint('splitPower', options.splitPower ?? EXTRACTOR_DEFAULT.SPLIT_POWER, 2, 15),\n    testFunction('colorValidator', options.colorValidator ?? ((_red: number, _green: number, _blue: number, _alpha?: number) => (_alpha ?? 255) > 250)),\n    testNumber('hueDistance', options.hueDistance ?? AVERAGE_DEFAULT.HUE, 0, 1),\n    testNumber('saturationDistance', options.saturationDistance ?? AVERAGE_DEFAULT.LIGHTNESS, 0, 1),\n    testNumber('lightnessDistance', options.lightnessDistance ?? AVERAGE_DEFAULT.SATURATION, 0, 1),\n    (options as BrowserOptions).crossOrigin ?? null\n  ]\n}\n","import Color from './Color'\n\n/**\n * Manage list of colors to optimize and merge neighbors colors.\n *\n * @export\n * @class BudGroup\n */\nexport default class BudGroup {\n\n  _count: number\n  _children: { [key: number]: Color }\n  _maxWeight: number | undefined\n\n  /**\n   * Store colors or groups and _count similiar groups in the image.\n   */\n  constructor () {\n    this._count = 1\n    this._children = { }\n  }\n\n  /**\n   * Add color to the group.\n   */\n  addColor (_hex: number, _red: number, _green: number, _blue: number) {\n    if (this._children[_hex]) {\n      this._children[_hex]._count++\n    } else {\n      this._children[_hex] = new Color(_red, _green, _blue, _hex)\n    }\n\n    return this._children[_hex]\n  }\n\n  /**\n   * Get list of groups of list of colors.\n   */\n  getList () {\n    return (Object.keys(this._children) as unknown[] as number[])\n      .map((key) => this._children[key])\n  }\n\n  /**\n   * Max color weight between the list colors, depends of his saturation and his _count.\n   */\n   getMaxWeight (_count: number): number {\n    if (this._maxWeight === undefined) {\n      const list = this.getList()\n        .map((child) => child._count / _count)\n\n      list.sort((a, b) => b - a)\n      this._maxWeight = list[0] || 0\n    }\n\n    return this._maxWeight \n  }\n\n  /**\n   * Color with the the max weight between the list colors, depends of his saturation and his _count.\n   */\n  getMaxWeightColor (_count: number) {\n    const list = this.getList()\n    list.sort((a, b) => {\n      return (b._count / _count) - (a._count / _count)\n    })\n\n    return list[0]\n  }\n\n  /**\n   * Max _count of colors for a group of colors.\n   */\n  getMaxCountColor () {\n    const list = this.getList()\n    const biggest = list.reduce((a, b) => a._count >= b._count ? a : b)\n    return biggest\n  }\n}\n","import Color from './Color'\nimport BudGroup from './BudGroup'\n\n/**\n * RootGroup colors with algorithms to optimize and merge neighbors colors.\n * \n * @class\n * @classdesc Manage list of colors or groups.\n */\nexport default class RootGroup {\n  _count: number\n  _children: { [key: number]: RootGroup | BudGroup }\n  _maxWeight: number | undefined\n\n  /**\n   * Store colors or groups and _count similiar groups in the image.\n   */\n  constructor () {\n    this._count = 1\n    this._children = { }\n  }\n\n  /**\n   * Add a key for a color, this key is a simplification to find neighboring colors.\n   * Neighboring colors has same key.\n   */\n  addRootGroup (key: number) {\n    if (this._children[key]) {\n      this._children[key]._count++\n    } else {\n      this._children[key] = new RootGroup()\n    }\n\n    return this._children[key] as RootGroup\n  }\n\n  /**\n   * Get list of groups of list of colors.\n   */\n  getList () {\n    return (Object.keys(this._children) as unknown[] as number[])\n      .map((key) => this._children[key])\n  }\n\n  /**\n   * Add a key for a color, this key is a simplification to find neighboring colors.\n   * Neighboring colors has same key.\n   */\n   addBudGroup (key: number) {\n    if (this._children[key]) {\n      this._children[key]._count++\n    } else {\n      this._children[key] = new BudGroup()\n    }\n\n    return this._children[key] as BudGroup\n  }\n\n  /**\n   * Max color weight between the list colors, depends of his saturation and his _count.\n   */\n  getMaxWeight (_count: number): number {\n    if (this._maxWeight === undefined) {\n      const list = this.getList()\n        .map((child) => child._count / _count)\n\n      list.sort((a, b) => b - a)\n      this._maxWeight = list[0] || 0\n    }\n\n    return this._maxWeight \n  }\n\n  /**\n   * Color with the the max weight between the list colors, depends of his saturation and his _count.\n   */\n  getMaxWeightColor (_count: number): Color {\n    const list = this.getList()\n    list.sort((a, b) => {\n      return (b._count / _count) - (a._count / _count)\n    })\n\n    return list[0].getMaxWeightColor(_count)\n  }\n\n  /**\n   * Max _count of colors for a group of colors.\n   */\n  getMaxCountColor (): Color {\n    const list = this.getList()\n    const biggest = list.reduce((a, b) => a.getMaxCountColor()._count >= b.getMaxCountColor()._count ? a : b)\n    return biggest.getMaxCountColor()\n  }\n\n  /**\n   * List of colors sorted by importance (neighboring hare calculated by distance and removed).\n   * Importance is calculated with the saturation and _count of neighboring colors.\n   */\n  getColors (_distance: number, _count: number) {\n    const list = this.getList()\n      .map((child) => {\n        const { _count } = child\n        const color = child.getMaxCountColor()\n        color._count = _count\n        return color\n      })\n\n    list.sort((a, b) => (b._count / _count) - (a._count / _count))\n\n    const newList: Color[] = []\n    list.forEach((color) => {\n      const near = newList.find((col) => Color.distance(col, color) < _distance)\n      if (!near) {\n        newList.push(color)\n      } else {\n        near._count += color._count\n      }\n    })\n\n    return newList\n  }\n}\n","import RootGroup from '../color/RootGroup'\n\n/**\n * Run extract process and get list of colors.\n */\nexport default (\n  { data, width, height }: ImageData | { data: Uint8ClampedArray | number[], width?: number, height?: number },\n  _pixels: number,\n  _distance: number,\n  _splitPower: number,\n  _colorValidator: (red: number, green: number, blue: number, alpha: number) => boolean\n) => {\n  const rootGroup = new RootGroup()\n  const reducer = (width && height) ? Math.floor(width * height / _pixels) || 1 : 1\n  \n  for (let i = 0; i < data.length; i += 4 * reducer) {\n    const r = data[i] // 0 -> 255\n    const g = data[i + 1]\n    const b = data[i + 2]\n    const a = data[i + 3]\n\n    if (_colorValidator(r, g, b, a)) {\n      const real = r << 16 | g << 8 | b\n      const medium = (r >> 4 & 0xF) << 8 | (g >> 4 & 0xF) << 4 | (b >> 4 & 0xF)\n      const small = Math.round(r * (_splitPower - 1) / 255) * (_splitPower * _splitPower) + Math.round(g * (_splitPower - 1) / 255) * _splitPower + Math.round(b * (_splitPower - 1) / 255)\n\n      const smallGroup = rootGroup.addRootGroup(small)\n      const mediumGroup = smallGroup.addBudGroup(medium)\n      mediumGroup.addColor(real, r, g, b)\n    }\n  }\n  \n  return rootGroup.getColors(_distance, _pixels)\n}\n","import Color from \"./color/Color\"\nimport sortColors from \"./sort/sortColors\"\nimport { createFinalColor } from \"./color/FinalColor\"\nimport { BrowserOptions, NodeOptions } from \"./types/Options\"\nimport cleanInputs from \"./extract/cleanInputs\"\nimport extractor from \"./extract/extractor\"\n\n/**\n * Sort colors and generate standard list of colors.\n */\nexport const sortFinalColors = (_colors: Color[], _pixels: number, _hueDistance: number, _saturationDistance: number, _lightnessDistance: number) => {\n  const list = sortColors(_colors, _pixels, _hueDistance, _saturationDistance, _lightnessDistance)\n  return list.map(color => createFinalColor(color, _pixels))\n}\n\n/**\n * Extract colors from an ImageData object.\n */\nexport const extractColorsFromImageData = (imageData: ImageData | { data: Uint8ClampedArray | number[], width?: number, height?: number }, options: NodeOptions | BrowserOptions = {}) => {\n  const [_pixels, _distance, _splitPower, _colorValidator, _hueDistance, _saturationDistance, _lightnessDistance] = cleanInputs(options)\n  const colors = extractor(imageData, _pixels, _distance, _splitPower, _colorValidator)\n  const px = (imageData.width && imageData.height) ? Math.min(imageData.width * imageData.height, _pixels) : _pixels\n  return sortFinalColors(colors, px, _hueDistance, _saturationDistance, _lightnessDistance)\n}\n","import Color from \"../color/Color\";\nimport { AverageManager } from \"./AverageManager\";\n\nexport default (\n  list: Color[],\n  _pixels: number,\n  _hueDistance: number,\n  _saturationDistance: number,\n  _lightnessDistance: number,\n) => {\n  const averageManager = new AverageManager(_hueDistance, _saturationDistance, _lightnessDistance)\n  list.forEach(color => averageManager.addColor(color))\n\n  const sorted = averageManager.getGroups()\n\n  sorted.sort((a, b) => {\n    const bPower = (b._intensity + 0.1) * (0.9 - b._count / _pixels)\n    const aPower = (a._intensity + 0.1) * (0.9 - a._count / _pixels)\n    return bPower - aPower \n  })\n  return sorted\n} \n","import { extractColorsFromImageData } from \"./extractColors\"\nimport { sortFinalColors } from \"./extractColors\"\nimport cleanInputs from \"./extract/cleanInputs\"\nimport extractor from \"./extract/extractor\"\nimport { FinalColor } from \"./types/Color\"\nimport type { BrowserOptions } from \"./types/Options\"\n\n/**\n * Extract ImageData from image.\n * Reduce image to a pixel count.\n */\nconst getImageData = (_image: HTMLImageElement, _pixels: number) => {\n  const currentPixels = _image.width * _image.height\n  const width = currentPixels < _pixels ? _image.width : Math.round(_image.width * Math.sqrt(_pixels / currentPixels))\n  const height = currentPixels < _pixels ? _image.height : Math.round(_image.height * Math.sqrt(_pixels / currentPixels))\n\n  const canvas = document.createElement('canvas')\n  canvas.width = width\n  canvas.height = height\n\n  const context = canvas.getContext('2d') as CanvasRenderingContext2D\n  context.drawImage(_image, 0, 0, _image.width, _image.height, 0, 0, width, height)\n\n  return context.getImageData(0, 0, width, height)\n}\n\n/**\n * Extract colors from an HTMLImageElement.\n */\nconst extractColorsFromImage = (image: HTMLImageElement, options: BrowserOptions = {}) => {\n  const [_pixels, _distance, _splitPower, _colorValidator, _hueDistance, _saturationDistance, _lightnessDistance, _crossOrigin] = cleanInputs(options)\n  image.crossOrigin = _crossOrigin\n  return new Promise((resolve: (value: FinalColor[]) => void) => {\n    const extract = (image: HTMLImageElement) => {\n      const imageData = getImageData(image, _pixels)\n      const _colors = extractor(imageData, _pixels, _distance, _splitPower, _colorValidator)\n      resolve(sortFinalColors(_colors, _pixels, _hueDistance, _saturationDistance, _lightnessDistance))\n    }\n\n    if (image.complete) {\n      extract(image)\n    } else {\n      const imageLoaded = () => {\n        image.removeEventListener('load', imageLoaded)\n        extract(image)\n      }\n      image.addEventListener('load', imageLoaded)\n    }\n  })\n}\n\n/**\n * Extract colors from a path.\n * The image will be downloaded.\n */\nconst extractColorsFromSrc = (src: string, options: BrowserOptions = {}) => {\n  const image = new Image()\n  image.src = src\n  return extractColorsFromImage(image, options)\n}\n\n/**\n * Extract colors from a picture.\n */\nconst extractColors = (picture: string | HTMLImageElement | ImageData | { data: Uint8ClampedArray | number[], width?: number, height?: number }, options?: BrowserOptions) => {\n\n  if (picture instanceof Image) {\n    return extractColorsFromImage(picture, options)\n  }\n\n  if (picture instanceof ImageData || (picture instanceof Object && picture.data)) {\n    return new Promise((resolve: (value: FinalColor[]) => void) => {\n      resolve(extractColorsFromImageData(picture, options))\n    })\n  }\n\n  if (typeof picture === \"string\") {\n    return extractColorsFromSrc(picture, options)\n  }\n\n  throw new Error(`Can not analyse picture`)\n}\n\nexport {\n  extractColorsFromImageData,\n  extractColorsFromImage,\n  extractColorsFromSrc,\n  extractColors\n}\n\nexport default extractColors\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}