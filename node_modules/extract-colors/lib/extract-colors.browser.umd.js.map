{"version":3,"file":"extract-colors.browser.umd.js","sources":["../src/color/Color.ts","../src/sort/AverageGroup.ts","../src/sort/AverageManager.ts","../src/color/FinalColor.ts","../src/extract/cleanInputs.ts","../src/color/BudGroup.ts","../src/color/RootGroup.ts","../src/extract/extractor.ts","../src/extractColors.ts","../src/sort/sortColors.ts","../src/extractColors.browser.ts"],"sourcesContent":["/**\n * Informations like saturation or count of pixels in image.\n * \n * @class\n * @classdesc Calculate some informations and store data about color.\n */\nexport default class Color {\n  \n  _red: number\n  _green: number\n  _blue: number\n  _hex: number\n  _count = 1\n\n  private __saturation = -1\n  private __hue = -1\n  private __lightness = -1\n  private __intensity = -1\n\n  /**\n   * Set red, green and blue colors to create the Color object.\n   */\n  constructor (red: number, green: number, blue: number, hex = red << 16 | green << 8 | blue) {\n\n    this._red = red\n    this._green = green\n    this._blue = blue\n    this._hex = hex\n  }\n\n  /**\n   * Distance between two colors.\n   * - Minimum is 0 (between two same colors)\n   * - Maximum is 1 (for example between black and white)\n   */\n  static distance (colorA: Color, colorB: Color) {\n    return (Math.abs(colorB._red - colorA._red) + Math.abs(colorB._green - colorA._green) + Math.abs(colorB._blue - colorA._blue)) / (3 * 0xFF)\n  }  \n\n  updateHSL () {\n    const red = this._red / 255\n    const green = this._green / 255\n    const blue = this._blue / 255\n\n    const max = Math.max(red, green, blue)\n    const min = Math.min(red, green, blue)\n\n    this.__lightness = (max + min) / 2\n\n    // achromatic\n    if (max === min) {\n      this.__hue = 0\n      this.__saturation = 0\n      this.__intensity = 0\n    } else {\n      const distance = max - min;\n      \n      this.__saturation = this.__lightness > 0.5 ? distance / (2 - max - min) : distance / (max + min)\n      this.__intensity = this.__saturation * ((0.5 - Math.abs(0.5 - this.__lightness)) * 2)\n      switch (max) {\n        case red:\n          this.__hue = ((green - blue) / distance + (green < blue ? 6 : 0)) / 6\n          break;\n        case green:\n          this.__hue = ((blue - red) / distance + 2) / 6\n          break;\n        case blue:\n          this.__hue = ((red - green) / distance + 4) / 6\n          break;\n      }\n    }\n\n  }\n\n  /**\n   * Hue from 0 to 1\n   */\n  get _hue () {\n    if (this.__hue === -1) {\n      this.updateHSL()\n    }\n    return this.__hue\n  }\n\n  /**\n   * Saturation from 0 to 1\n   */\n  get _saturation () {\n    if (this.__saturation === -1) {\n      this.updateHSL()\n    }\n    return this.__saturation\n  }\n\n  /**\n   * Lightness from 0 to 1\n   */\n  get _lightness () {\n    if (this.__lightness === -1) {\n      this.updateHSL()\n    }\n    return this.__lightness\n  }\n  \n  /**\n   * Color intensity from 0 to 1\n   */\n  get _intensity () {\n    if (this.__intensity === -1) {\n      this.updateHSL()\n    }\n    return this.__intensity\n  }\n}\n","import Color from \"../color/Color\";\n\nconst distance = (a: number, b: number) => Math.abs(a - b)\nconst hueDistance = (a: number, b: number) =>\n  Math.min(distance(a, b), distance((a + 0.5) % 1, (b + 0.5) % 1))\n\nexport class AverageGroup {\n  colors: Color[] = []\n  private _average: Color | null = null\n\n  addColor(color: Color) {\n    this.colors.push(color)\n    this._average = null\n  }\n\n  isSamePalette(color: Color, hue: number, saturation: number, lightness: number) {\n    for (let i = 0; i < this.colors.length; i++) {\n      const currentColor = this.colors[i]\n      const isSame = \n        hueDistance(currentColor._hue, color._hue) < hue &&\n        distance(currentColor._saturation, color._saturation) < saturation &&\n        distance(currentColor._lightness, color._lightness) < lightness\n\n      if (!isSame) {\n        return false\n      }\n    }\n    return true\n  }\n\n  get average () {\n    if (!this._average) {\n      const { r, g, b } = this.colors.reduce((total, color) => {\n        total.r += color._red\n        total.g += color._green\n        total.b += color._blue\n        return total\n      }, { r: 0, g: 0, b: 0 })\n\n      const total = this.colors.reduce((_count, color) => _count + color._count, 0)\n      this._average = new Color(\n        Math.round(r / this.colors.length),\n        Math.round(g / this.colors.length),\n        Math.round(b / this.colors.length)\n      )\n      this._average._count = total\n    }\n    return this._average\n  } \n}","import Color from \"../color/Color\";\nimport { AverageGroup } from \"./AverageGroup\";\n\n\nexport class AverageManager {\n\n  _hue:number\n  _saturation:number\n  _lightness:number\n\n  private _groups: AverageGroup[] = []\n\n  constructor (\n    hue: number,\n    saturation: number,\n    lightness: number\n  ) {\n    this._hue = hue\n    this._saturation = saturation\n    this._lightness = lightness\n  }\n\n  addColor(color: Color) {\n    const samePalette = this._groups.find(averageGroup => averageGroup.isSamePalette(color, this._hue, this._saturation, this._lightness))\n    if (samePalette) {\n      samePalette.addColor(color)\n    } else {\n      const averageGroup = new AverageGroup()\n      averageGroup.addColor(color)\n      this._groups.push(averageGroup)\n    }\n  }\n\n  getGroups() {\n    return this._groups.map(averageGroup => averageGroup.average)\n  }\n}","import { FinalColor } from \"../types/Color\";\nimport Color from \"./Color\";\n\nexport const createFinalColor = (color: Color, pixels: number): FinalColor => {\n  return {\n    hex: `#${'0'.repeat(6 - color._hex.toString(16).length)}${color._hex.toString(16)}`,\n    red: color._red,\n    green: color._green,\n    blue: color._blue,\n    area: color._count / pixels,\n    hue: color._hue,\n    saturation: color._saturation,\n    lightness: color._lightness,\n    intensity: color._intensity,\n  }\n}","import { BrowserOptions, NodeOptions } from \"../types/Options\"\n\n/**\n * Default extractor values\n */\nexport const enum EXTRACTOR_DEFAULT {\n  PIXELS = 10000,\n  DISTANCE = 0.12,\n  SPLIT_POWER = 10\n}\n\n/**\n * Default average values\n */\nexport const enum AVERAGE_DEFAULT {\n  HUE = 1/12,\n  SATURATION = 1/5,\n  LIGHTNESS = 1/5,\n}\n\n/**\n * Test if value is an integer.\n */\nconst testUint = <T = number>(label: string, val: T, min = 0, max = Number.MAX_SAFE_INTEGER) => {\n  if (!Number.isInteger(val) || val < min || val > max) {\n    throw new Error(`${label} is invalid (${ val })`)\n  }\n\n  return val\n}\n\n/**\n * Test if value is a number.\n */\nconst testNumber = <T = number>(label: string, val: T, min = 0, max = Number.MAX_VALUE) => {\n  if (Number(val) !== val || val < min || val > max) {\n    throw new Error(`${label} is invalid (${ val })`)\n  }\n\n  return val\n}\n\n/**\n * Test if value is a function.\n */\nconst testFunction = <T = () => void>(label: string, val: T) => {\n  if (!val || {}.toString.call(val) !== '[object Function]') {\n    throw new Error(`${label} is invalid (${ val })`)\n  }\n\n  return val\n}\n\nexport default (options:BrowserOptions | NodeOptions): [\n  number,\n  number,\n  number,\n  (red: number, green: number, blue: number, alpha: number) => boolean,\n  number,\n  number,\n  number,\n  \"\" | \"anonymous\" | \"use-credentials\" | null,\n] => {\n  return [\n    testUint('pixels', options.pixels ?? EXTRACTOR_DEFAULT.PIXELS, 1),\n    testNumber('distance', options.distance ?? EXTRACTOR_DEFAULT.DISTANCE, 0, 1),\n    testUint('splitPower', options.splitPower ?? EXTRACTOR_DEFAULT.SPLIT_POWER, 2, 15),\n    testFunction('colorValidator', options.colorValidator ?? ((_red: number, _green: number, _blue: number, _alpha?: number) => (_alpha ?? 255) > 250)),\n    testNumber('hueDistance', options.hueDistance ?? AVERAGE_DEFAULT.HUE, 0, 1),\n    testNumber('saturationDistance', options.saturationDistance ?? AVERAGE_DEFAULT.LIGHTNESS, 0, 1),\n    testNumber('lightnessDistance', options.lightnessDistance ?? AVERAGE_DEFAULT.SATURATION, 0, 1),\n    (options as BrowserOptions).crossOrigin ?? null\n  ]\n}\n","import Color from './Color'\n\n/**\n * Manage list of colors to optimize and merge neighbors colors.\n *\n * @export\n * @class BudGroup\n */\nexport default class BudGroup {\n\n  _count: number\n  _children: { [key: number]: Color }\n  _maxWeight: number | undefined\n\n  /**\n   * Store colors or groups and _count similiar groups in the image.\n   */\n  constructor () {\n    this._count = 1\n    this._children = { }\n  }\n\n  /**\n   * Add color to the group.\n   */\n  addColor (_hex: number, _red: number, _green: number, _blue: number) {\n    if (this._children[_hex]) {\n      this._children[_hex]._count++\n    } else {\n      this._children[_hex] = new Color(_red, _green, _blue, _hex)\n    }\n\n    return this._children[_hex]\n  }\n\n  /**\n   * Get list of groups of list of colors.\n   */\n  getList () {\n    return (Object.keys(this._children) as unknown[] as number[])\n      .map((key) => this._children[key])\n  }\n\n  /**\n   * Max color weight between the list colors, depends of his saturation and his _count.\n   */\n   getMaxWeight (_count: number): number {\n    if (this._maxWeight === undefined) {\n      const list = this.getList()\n        .map((child) => child._count / _count)\n\n      list.sort((a, b) => b - a)\n      this._maxWeight = list[0] || 0\n    }\n\n    return this._maxWeight \n  }\n\n  /**\n   * Color with the the max weight between the list colors, depends of his saturation and his _count.\n   */\n  getMaxWeightColor (_count: number) {\n    const list = this.getList()\n    list.sort((a, b) => {\n      return (b._count / _count) - (a._count / _count)\n    })\n\n    return list[0]\n  }\n\n  /**\n   * Max _count of colors for a group of colors.\n   */\n  getMaxCountColor () {\n    const list = this.getList()\n    const biggest = list.reduce((a, b) => a._count >= b._count ? a : b)\n    return biggest\n  }\n}\n","import Color from './Color'\nimport BudGroup from './BudGroup'\n\n/**\n * RootGroup colors with algorithms to optimize and merge neighbors colors.\n * \n * @class\n * @classdesc Manage list of colors or groups.\n */\nexport default class RootGroup {\n  _count: number\n  _children: { [key: number]: RootGroup | BudGroup }\n  _maxWeight: number | undefined\n\n  /**\n   * Store colors or groups and _count similiar groups in the image.\n   */\n  constructor () {\n    this._count = 1\n    this._children = { }\n  }\n\n  /**\n   * Add a key for a color, this key is a simplification to find neighboring colors.\n   * Neighboring colors has same key.\n   */\n  addRootGroup (key: number) {\n    if (this._children[key]) {\n      this._children[key]._count++\n    } else {\n      this._children[key] = new RootGroup()\n    }\n\n    return this._children[key] as RootGroup\n  }\n\n  /**\n   * Get list of groups of list of colors.\n   */\n  getList () {\n    return (Object.keys(this._children) as unknown[] as number[])\n      .map((key) => this._children[key])\n  }\n\n  /**\n   * Add a key for a color, this key is a simplification to find neighboring colors.\n   * Neighboring colors has same key.\n   */\n   addBudGroup (key: number) {\n    if (this._children[key]) {\n      this._children[key]._count++\n    } else {\n      this._children[key] = new BudGroup()\n    }\n\n    return this._children[key] as BudGroup\n  }\n\n  /**\n   * Max color weight between the list colors, depends of his saturation and his _count.\n   */\n  getMaxWeight (_count: number): number {\n    if (this._maxWeight === undefined) {\n      const list = this.getList()\n        .map((child) => child._count / _count)\n\n      list.sort((a, b) => b - a)\n      this._maxWeight = list[0] || 0\n    }\n\n    return this._maxWeight \n  }\n\n  /**\n   * Color with the the max weight between the list colors, depends of his saturation and his _count.\n   */\n  getMaxWeightColor (_count: number): Color {\n    const list = this.getList()\n    list.sort((a, b) => {\n      return (b._count / _count) - (a._count / _count)\n    })\n\n    return list[0].getMaxWeightColor(_count)\n  }\n\n  /**\n   * Max _count of colors for a group of colors.\n   */\n  getMaxCountColor (): Color {\n    const list = this.getList()\n    const biggest = list.reduce((a, b) => a.getMaxCountColor()._count >= b.getMaxCountColor()._count ? a : b)\n    return biggest.getMaxCountColor()\n  }\n\n  /**\n   * List of colors sorted by importance (neighboring hare calculated by distance and removed).\n   * Importance is calculated with the saturation and _count of neighboring colors.\n   */\n  getColors (_distance: number, _count: number) {\n    const list = this.getList()\n      .map((child) => {\n        const { _count } = child\n        const color = child.getMaxCountColor()\n        color._count = _count\n        return color\n      })\n\n    list.sort((a, b) => (b._count / _count) - (a._count / _count))\n\n    const newList: Color[] = []\n    list.forEach((color) => {\n      const near = newList.find((col) => Color.distance(col, color) < _distance)\n      if (!near) {\n        newList.push(color)\n      } else {\n        near._count += color._count\n      }\n    })\n\n    return newList\n  }\n}\n","import RootGroup from '../color/RootGroup'\n\n/**\n * Run extract process and get list of colors.\n */\nexport default (\n  { data, width, height }: ImageData | { data: Uint8ClampedArray | number[], width?: number, height?: number },\n  _pixels: number,\n  _distance: number,\n  _splitPower: number,\n  _colorValidator: (red: number, green: number, blue: number, alpha: number) => boolean\n) => {\n  const rootGroup = new RootGroup()\n  const reducer = (width && height) ? Math.floor(width * height / _pixels) || 1 : 1\n  \n  for (let i = 0; i < data.length; i += 4 * reducer) {\n    const r = data[i] // 0 -> 255\n    const g = data[i + 1]\n    const b = data[i + 2]\n    const a = data[i + 3]\n\n    if (_colorValidator(r, g, b, a)) {\n      const real = r << 16 | g << 8 | b\n      const medium = (r >> 4 & 0xF) << 8 | (g >> 4 & 0xF) << 4 | (b >> 4 & 0xF)\n      const small = Math.round(r * (_splitPower - 1) / 255) * (_splitPower * _splitPower) + Math.round(g * (_splitPower - 1) / 255) * _splitPower + Math.round(b * (_splitPower - 1) / 255)\n\n      const smallGroup = rootGroup.addRootGroup(small)\n      const mediumGroup = smallGroup.addBudGroup(medium)\n      mediumGroup.addColor(real, r, g, b)\n    }\n  }\n  \n  return rootGroup.getColors(_distance, _pixels)\n}\n","import Color from \"./color/Color\"\nimport sortColors from \"./sort/sortColors\"\nimport { createFinalColor } from \"./color/FinalColor\"\nimport { BrowserOptions, NodeOptions } from \"./types/Options\"\nimport cleanInputs from \"./extract/cleanInputs\"\nimport extractor from \"./extract/extractor\"\n\n/**\n * Sort colors and generate standard list of colors.\n */\nexport const sortFinalColors = (_colors: Color[], _pixels: number, _hueDistance: number, _saturationDistance: number, _lightnessDistance: number) => {\n  const list = sortColors(_colors, _pixels, _hueDistance, _saturationDistance, _lightnessDistance)\n  return list.map(color => createFinalColor(color, _pixels))\n}\n\n/**\n * Extract colors from an ImageData object.\n */\nexport const extractColorsFromImageData = (imageData: ImageData | { data: Uint8ClampedArray | number[], width?: number, height?: number }, options: NodeOptions | BrowserOptions = {}) => {\n  const [_pixels, _distance, _splitPower, _colorValidator, _hueDistance, _saturationDistance, _lightnessDistance] = cleanInputs(options)\n  const colors = extractor(imageData, _pixels, _distance, _splitPower, _colorValidator)\n  const px = (imageData.width && imageData.height) ? Math.min(imageData.width * imageData.height, _pixels) : _pixels\n  return sortFinalColors(colors, px, _hueDistance, _saturationDistance, _lightnessDistance)\n}\n","import Color from \"../color/Color\";\nimport { AverageManager } from \"./AverageManager\";\n\nexport default (\n  list: Color[],\n  _pixels: number,\n  _hueDistance: number,\n  _saturationDistance: number,\n  _lightnessDistance: number,\n) => {\n  const averageManager = new AverageManager(_hueDistance, _saturationDistance, _lightnessDistance)\n  list.forEach(color => averageManager.addColor(color))\n\n  const sorted = averageManager.getGroups()\n\n  sorted.sort((a, b) => {\n    const bPower = (b._intensity + 0.1) * (0.9 - b._count / _pixels)\n    const aPower = (a._intensity + 0.1) * (0.9 - a._count / _pixels)\n    return bPower - aPower \n  })\n  return sorted\n} \n","import { extractColorsFromImageData } from \"./extractColors\"\nimport { sortFinalColors } from \"./extractColors\"\nimport cleanInputs from \"./extract/cleanInputs\"\nimport extractor from \"./extract/extractor\"\nimport { FinalColor } from \"./types/Color\"\nimport type { BrowserOptions } from \"./types/Options\"\n\n/**\n * Extract ImageData from image.\n * Reduce image to a pixel count.\n */\nconst getImageData = (_image: HTMLImageElement, _pixels: number) => {\n  const currentPixels = _image.width * _image.height\n  const width = currentPixels < _pixels ? _image.width : Math.round(_image.width * Math.sqrt(_pixels / currentPixels))\n  const height = currentPixels < _pixels ? _image.height : Math.round(_image.height * Math.sqrt(_pixels / currentPixels))\n\n  const canvas = document.createElement('canvas')\n  canvas.width = width\n  canvas.height = height\n\n  const context = canvas.getContext('2d') as CanvasRenderingContext2D\n  context.drawImage(_image, 0, 0, _image.width, _image.height, 0, 0, width, height)\n\n  return context.getImageData(0, 0, width, height)\n}\n\n/**\n * Extract colors from an HTMLImageElement.\n */\nconst extractColorsFromImage = (image: HTMLImageElement, options: BrowserOptions = {}) => {\n  const [_pixels, _distance, _splitPower, _colorValidator, _hueDistance, _saturationDistance, _lightnessDistance, _crossOrigin] = cleanInputs(options)\n  image.crossOrigin = _crossOrigin\n  return new Promise((resolve: (value: FinalColor[]) => void) => {\n    const extract = (image: HTMLImageElement) => {\n      const imageData = getImageData(image, _pixels)\n      const _colors = extractor(imageData, _pixels, _distance, _splitPower, _colorValidator)\n      resolve(sortFinalColors(_colors, _pixels, _hueDistance, _saturationDistance, _lightnessDistance))\n    }\n\n    if (image.complete) {\n      extract(image)\n    } else {\n      const imageLoaded = () => {\n        image.removeEventListener('load', imageLoaded)\n        extract(image)\n      }\n      image.addEventListener('load', imageLoaded)\n    }\n  })\n}\n\n/**\n * Extract colors from a path.\n * The image will be downloaded.\n */\nconst extractColorsFromSrc = (src: string, options: BrowserOptions = {}) => {\n  const image = new Image()\n  image.src = src\n  return extractColorsFromImage(image, options)\n}\n\n/**\n * Extract colors from a picture.\n */\nconst extractColors = (picture: string | HTMLImageElement | ImageData | { data: Uint8ClampedArray | number[], width?: number, height?: number }, options?: BrowserOptions) => {\n\n  if (picture instanceof Image) {\n    return extractColorsFromImage(picture, options)\n  }\n\n  if (picture instanceof ImageData || (picture instanceof Object && picture.data)) {\n    return new Promise((resolve: (value: FinalColor[]) => void) => {\n      resolve(extractColorsFromImageData(picture, options))\n    })\n  }\n\n  if (typeof picture === \"string\") {\n    return extractColorsFromSrc(picture, options)\n  }\n\n  throw new Error(`Can not analyse picture`)\n}\n\nexport {\n  extractColorsFromImageData,\n  extractColorsFromImage,\n  extractColorsFromSrc,\n  extractColors\n}\n\nexport default extractColors\n"],"names":["Color","constructor","red","green","blue","hex","this","_count","__saturation","__hue","__lightness","__intensity","_red","_green","_blue","_hex","static","colorA","colorB","Math","abs","updateHSL","max","min","distance","_hue","_saturation","_lightness","_intensity","a","b","AverageGroup","colors","_average","addColor","color","push","isSamePalette","hue","saturation","lightness","i","length","currentColor","average","r","G","g","reduce","total","round","AverageManager","_groups","samePalette","find","averageGroup","getGroups","map","testUint","label","val","Number","MAX_SAFE_INTEGER","isInteger","Error","testNumber","MAX_VALUE","testFunction","toString","call","cleanInputs","options","_a","pixels","_b","_c","splitPower","_d","colorValidator","_alpha","_e","hueDistance","_f","saturationDistance","_g","lightnessDistance","_h","crossOrigin","BudGroup","_children","getList","Object","keys","key","getMaxWeight","_maxWeight","list","child","sort","getMaxWeightColor","getMaxCountColor","RootGroup","addRootGroup","addBudGroup","getColors","_distance","newList","forEach","near","col","extractor","data","width","height","_pixels","_splitPower","_colorValidator","rootGroup","reducer","floor","real","medium","small","sortFinalColors","_colors","_hueDistance","_saturationDistance","_lightnessDistance","averageManager","sorted","sortColors","repeat","area","intensity","createFinalColor","extractColorsFromImageData","imageData","px","extractColorsFromImage","image","_crossOrigin","Promise","resolve","extract","_image","currentPixels","sqrt","canvas","document","createElement","context","getContext","drawImage","getImageData","complete","imageLoaded","removeEventListener","addEventListener","extractColorsFromSrc","src","Image","extractColors","picture","ImageData"],"mappings":"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"}