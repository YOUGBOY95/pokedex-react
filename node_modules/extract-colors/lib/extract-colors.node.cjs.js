"use strict";Object.defineProperties(exports,{t:{value:!0},[Symbol.toStringTag]:{value:"Module"}});class t{constructor(t,s,i,r=t<<16|s<<8|i){this.i=1,this.h=-1,this.o=-1,this.u=-1,this.l=-1,this.g=t,this.M=s,this.C=i,this.p=r}static distance(t,s){return(Math.abs(s.g-t.g)+Math.abs(s.M-t.M)+Math.abs(s.C-t.C))/765}m(){const t=this.g/255,s=this.M/255,i=this.C/255,r=Math.max(t,s,i),e=Math.min(t,s,i);if(this.u=(r+e)/2,r===e)this.o=0,this.h=0,this.l=0;else{const h=r-e;switch(this.h=this.u>.5?h/(2-r-e):h/(r+e),this.l=this.h*(2*(.5-Math.abs(.5-this.u))),r){case t:this.o=((s-i)/h+(s<i?6:0))/6;break;case s:this.o=((i-t)/h+2)/6;break;case i:this.o=((t-s)/h+4)/6}}}get v(){return-1===this.o&&this.m(),this.o}get $(){return-1===this.h&&this.m(),this.h}get _(){return-1===this.u&&this.m(),this.u}get j(){return-1===this.l&&this.m(),this.l}}const s=(t,s)=>Math.abs(t-s);class i{constructor(){this.N=[],this.S=null}D(t){this.N.push(t),this.S=null}W(t,i,r,e){for(let o=0;o<this.N.length;o++){const a=this.N[o];if(!(h=a.v,n=t.v,Math.min(s(h,n),s((h+.5)%1,(n+.5)%1))<i&&s(a.$,t.$)<r&&s(a._,t._)<e))return!1}var h,n;return!0}get F(){if(!this.S){const{r:s,G:i,b:r}=this.N.reduce(((t,s)=>(t.r+=s.g,t.G+=s.M,t.b+=s.C,t)),{r:0,G:0,b:0}),e=this.N.reduce(((t,s)=>t+s.i),0);this.S=new t(Math.round(s/this.N.length),Math.round(i/this.N.length),Math.round(r/this.N.length)),this.S.i=e}return this.S}}class r{constructor(t,s,i){this.L=[],this.v=t,this.$=s,this._=i}D(t){const s=this.L.find((s=>s.W(t,this.v,this.$,this._)));if(s)s.D(t);else{const s=new i;s.D(t),this.L.push(s)}}O(){return this.L.map((t=>t.F))}}const e=(t,s,i=0,r=Number.MAX_SAFE_INTEGER)=>{if(!Number.isInteger(s)||s<i||s>r)throw new Error(`${t} is invalid (${s})`);return s},h=(t,s,i=0,r=Number.MAX_VALUE)=>{if(Number(s)!==s||s<i||s>r)throw new Error(`${t} is invalid (${s})`);return s},n=(t,s)=>{if(!s||"[object Function]"!=={}.toString.call(s))throw new Error(`${t} is invalid (${s})`);return s};class o{constructor(){this.i=1,this.P={}}D(s,i,r,e){return this.P[s]?this.P[s].i++:this.P[s]=new t(i,r,e,s),this.P[s]}k(){return Object.keys(this.P).map((t=>this.P[t]))}B(t){if(void 0===this.H){const s=this.k().map((s=>s.i/t));s.sort(((t,s)=>s-t)),this.H=s[0]||0}return this.H}I(t){const s=this.k();return s.sort(((s,i)=>i.i/t-s.i/t)),s[0]}R(){return this.k().reduce(((t,s)=>t.i>=s.i?t:s))}}class a{constructor(){this.i=1,this.P={}}V(t){return this.P[t]?this.P[t].i++:this.P[t]=new a,this.P[t]}k(){return Object.keys(this.P).map((t=>this.P[t]))}q(t){return this.P[t]?this.P[t].i++:this.P[t]=new o,this.P[t]}B(t){if(void 0===this.H){const s=this.k().map((s=>s.i/t));s.sort(((t,s)=>s-t)),this.H=s[0]||0}return this.H}I(t){const s=this.k();return s.sort(((s,i)=>i.i/t-s.i/t)),s[0].I(t)}R(){return this.k().reduce(((t,s)=>t.R().i>=s.R().i?t:s)).R()}A(s,i){const r=this.k().map((t=>{const{i:s}=t,i=t.R();return i.i=s,i}));r.sort(((t,s)=>s.i/i-t.i/i));const e=[];return r.forEach((i=>{const r=e.find((r=>t.distance(r,i)<s));r?r.i+=i.i:e.push(i)})),e}}const u=(t,s,i,e,h)=>{const n=((t,s,i,e,h)=>{const n=new r(i,e,h);t.forEach((t=>n.D(t)));const o=n.O();return o.sort(((t,i)=>(i.j+.1)*(.9-i.i/s)-(t.j+.1)*(.9-t.i/s))),o})(t,s,i,e,h);return n.map((t=>((t,s)=>({hex:`#${"0".repeat(6-t.p.toString(16).length)}${t.p.toString(16)}`,red:t.g,green:t.M,blue:t.C,area:t.i/s,hue:t.v,saturation:t.$,lightness:t._,intensity:t.j}))(t,s)))},c=(t,s={})=>{const[i,r,o,c,l,g,d]=(t=>{var s,i,r,o,a,u,c,l;return[e("pixels",null!=(s=t.pixels)?s:1e4,1),h("distance",null!=(i=t.distance)?i:.12,0,1),e("splitPower",null!=(r=t.splitPower)?r:10,2,15),n("colorValidator",null!=(o=t.colorValidator)?o:(t,s,i,r)=>(null!=r?r:255)>250),h("hueDistance",null!=(a=t.hueDistance)?a:.08333333333333333,0,1),h("saturationDistance",null!=(u=t.saturationDistance)?u:.2,0,1),h("lightnessDistance",null!=(c=t.lightnessDistance)?c:.2,0,1),null!=(l=t.crossOrigin)?l:null]})(s),M=(({data:t,width:s,height:i},r,e,h,n)=>{const o=new a,u=s&&i&&Math.floor(s*i/r)||1;for(let a=0;a<t.length;a+=4*u){const s=t[a],i=t[a+1],r=t[a+2];if(n(s,i,r,t[a+3])){const t=s<<16|i<<8|r,e=(s>>4&15)<<8|(i>>4&15)<<4|r>>4&15,n=Math.round(s*(h-1)/255)*(h*h)+Math.round(i*(h-1)/255)*h+Math.round(r*(h-1)/255);o.V(n).q(e).D(t,s,i,r)}}return o.A(e,r)})(t,i,r,o,c),w=t.width&&t.height?Math.min(t.width*t.height,i):i;return u(M,w,l,g,d)},l=(t,s)=>{if(t.data)return new Promise((i=>{i(c(t,s))}));throw new Error("Send imageData to extractColors")};exports.default=l,exports.extractColors=l,exports.extractColorsFromImage=()=>{throw new Error("Can not use extractColorsFromImage for Node.js")},exports.extractColorsFromImageData=c,exports.extractColorsFromSrc=()=>{throw new Error("Can not use extractColorsFromSrc for Node.js")};
//# sourceMappingURL=extract-colors.node.cjs.js.map
