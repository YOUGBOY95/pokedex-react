{"version":3,"file":"extract-colors.node.es.js","sources":["../src/color/Color.ts","../src/sort/AverageGroup.ts","../src/sort/AverageManager.ts","../src/sort/sortColors.ts","../src/color/FinalColor.ts","../src/extract/cleanInputs.ts","../src/color/BudGroup.ts","../src/color/RootGroup.ts","../src/extract/extractor.ts","../src/extractColors.ts","../src/extractColors.node.ts"],"sourcesContent":["/**\n * Informations like saturation or count of pixels in image.\n * \n * @class\n * @classdesc Calculate some informations and store data about color.\n */\nexport default class Color {\n  \n  _red: number\n  _green: number\n  _blue: number\n  _hex: number\n  _count = 1\n\n  private __saturation = -1\n  private __hue = -1\n  private __lightness = -1\n  private __intensity = -1\n\n  /**\n   * Set red, green and blue colors to create the Color object.\n   */\n  constructor (red: number, green: number, blue: number, hex = red << 16 | green << 8 | blue) {\n\n    this._red = red\n    this._green = green\n    this._blue = blue\n    this._hex = hex\n  }\n\n  /**\n   * Distance between two colors.\n   * - Minimum is 0 (between two same colors)\n   * - Maximum is 1 (for example between black and white)\n   */\n  static distance (colorA: Color, colorB: Color) {\n    return (Math.abs(colorB._red - colorA._red) + Math.abs(colorB._green - colorA._green) + Math.abs(colorB._blue - colorA._blue)) / (3 * 0xFF)\n  }  \n\n  updateHSL () {\n    const red = this._red / 255\n    const green = this._green / 255\n    const blue = this._blue / 255\n\n    const max = Math.max(red, green, blue)\n    const min = Math.min(red, green, blue)\n\n    this.__lightness = (max + min) / 2\n\n    // achromatic\n    if (max === min) {\n      this.__hue = 0\n      this.__saturation = 0\n      this.__intensity = 0\n    } else {\n      const distance = max - min;\n      \n      this.__saturation = this.__lightness > 0.5 ? distance / (2 - max - min) : distance / (max + min)\n      this.__intensity = this.__saturation * ((0.5 - Math.abs(0.5 - this.__lightness)) * 2)\n      switch (max) {\n        case red:\n          this.__hue = ((green - blue) / distance + (green < blue ? 6 : 0)) / 6\n          break;\n        case green:\n          this.__hue = ((blue - red) / distance + 2) / 6\n          break;\n        case blue:\n          this.__hue = ((red - green) / distance + 4) / 6\n          break;\n      }\n    }\n\n  }\n\n  /**\n   * Hue from 0 to 1\n   */\n  get _hue () {\n    if (this.__hue === -1) {\n      this.updateHSL()\n    }\n    return this.__hue\n  }\n\n  /**\n   * Saturation from 0 to 1\n   */\n  get _saturation () {\n    if (this.__saturation === -1) {\n      this.updateHSL()\n    }\n    return this.__saturation\n  }\n\n  /**\n   * Lightness from 0 to 1\n   */\n  get _lightness () {\n    if (this.__lightness === -1) {\n      this.updateHSL()\n    }\n    return this.__lightness\n  }\n  \n  /**\n   * Color intensity from 0 to 1\n   */\n  get _intensity () {\n    if (this.__intensity === -1) {\n      this.updateHSL()\n    }\n    return this.__intensity\n  }\n}\n","import Color from \"../color/Color\";\n\nconst distance = (a: number, b: number) => Math.abs(a - b)\nconst hueDistance = (a: number, b: number) =>\n  Math.min(distance(a, b), distance((a + 0.5) % 1, (b + 0.5) % 1))\n\nexport class AverageGroup {\n  colors: Color[] = []\n  private _average: Color | null = null\n\n  addColor(color: Color) {\n    this.colors.push(color)\n    this._average = null\n  }\n\n  isSamePalette(color: Color, hue: number, saturation: number, lightness: number) {\n    for (let i = 0; i < this.colors.length; i++) {\n      const currentColor = this.colors[i]\n      const isSame = \n        hueDistance(currentColor._hue, color._hue) < hue &&\n        distance(currentColor._saturation, color._saturation) < saturation &&\n        distance(currentColor._lightness, color._lightness) < lightness\n\n      if (!isSame) {\n        return false\n      }\n    }\n    return true\n  }\n\n  get average () {\n    if (!this._average) {\n      const { r, g, b } = this.colors.reduce((total, color) => {\n        total.r += color._red\n        total.g += color._green\n        total.b += color._blue\n        return total\n      }, { r: 0, g: 0, b: 0 })\n\n      const total = this.colors.reduce((_count, color) => _count + color._count, 0)\n      this._average = new Color(\n        Math.round(r / this.colors.length),\n        Math.round(g / this.colors.length),\n        Math.round(b / this.colors.length)\n      )\n      this._average._count = total\n    }\n    return this._average\n  } \n}","import Color from \"../color/Color\";\nimport { AverageGroup } from \"./AverageGroup\";\n\n\nexport class AverageManager {\n\n  _hue:number\n  _saturation:number\n  _lightness:number\n\n  private _groups: AverageGroup[] = []\n\n  constructor (\n    hue: number,\n    saturation: number,\n    lightness: number\n  ) {\n    this._hue = hue\n    this._saturation = saturation\n    this._lightness = lightness\n  }\n\n  addColor(color: Color) {\n    const samePalette = this._groups.find(averageGroup => averageGroup.isSamePalette(color, this._hue, this._saturation, this._lightness))\n    if (samePalette) {\n      samePalette.addColor(color)\n    } else {\n      const averageGroup = new AverageGroup()\n      averageGroup.addColor(color)\n      this._groups.push(averageGroup)\n    }\n  }\n\n  getGroups() {\n    return this._groups.map(averageGroup => averageGroup.average)\n  }\n}","import Color from \"../color/Color\";\nimport { AverageManager } from \"./AverageManager\";\n\nexport default (\n  list: Color[],\n  _pixels: number,\n  _hueDistance: number,\n  _saturationDistance: number,\n  _lightnessDistance: number,\n) => {\n  const averageManager = new AverageManager(_hueDistance, _saturationDistance, _lightnessDistance)\n  list.forEach(color => averageManager.addColor(color))\n\n  const sorted = averageManager.getGroups()\n\n  sorted.sort((a, b) => {\n    const bPower = (b._intensity + 0.1) * (0.9 - b._count / _pixels)\n    const aPower = (a._intensity + 0.1) * (0.9 - a._count / _pixels)\n    return bPower - aPower \n  })\n  return sorted\n} \n","import { FinalColor } from \"../types/Color\";\nimport Color from \"./Color\";\n\nexport const createFinalColor = (color: Color, pixels: number): FinalColor => {\n  return {\n    hex: `#${'0'.repeat(6 - color._hex.toString(16).length)}${color._hex.toString(16)}`,\n    red: color._red,\n    green: color._green,\n    blue: color._blue,\n    area: color._count / pixels,\n    hue: color._hue,\n    saturation: color._saturation,\n    lightness: color._lightness,\n    intensity: color._intensity,\n  }\n}","import { BrowserOptions, NodeOptions } from \"../types/Options\"\n\n/**\n * Default extractor values\n */\nexport const enum EXTRACTOR_DEFAULT {\n  PIXELS = 10000,\n  DISTANCE = 0.12,\n  SPLIT_POWER = 10\n}\n\n/**\n * Default average values\n */\nexport const enum AVERAGE_DEFAULT {\n  HUE = 1/12,\n  SATURATION = 1/5,\n  LIGHTNESS = 1/5,\n}\n\n/**\n * Test if value is an integer.\n */\nconst testUint = <T = number>(label: string, val: T, min = 0, max = Number.MAX_SAFE_INTEGER) => {\n  if (!Number.isInteger(val) || val < min || val > max) {\n    throw new Error(`${label} is invalid (${ val })`)\n  }\n\n  return val\n}\n\n/**\n * Test if value is a number.\n */\nconst testNumber = <T = number>(label: string, val: T, min = 0, max = Number.MAX_VALUE) => {\n  if (Number(val) !== val || val < min || val > max) {\n    throw new Error(`${label} is invalid (${ val })`)\n  }\n\n  return val\n}\n\n/**\n * Test if value is a function.\n */\nconst testFunction = <T = () => void>(label: string, val: T) => {\n  if (!val || {}.toString.call(val) !== '[object Function]') {\n    throw new Error(`${label} is invalid (${ val })`)\n  }\n\n  return val\n}\n\nexport default (options:BrowserOptions | NodeOptions): [\n  number,\n  number,\n  number,\n  (red: number, green: number, blue: number, alpha: number) => boolean,\n  number,\n  number,\n  number,\n  \"\" | \"anonymous\" | \"use-credentials\" | null,\n] => {\n  return [\n    testUint('pixels', options.pixels ?? EXTRACTOR_DEFAULT.PIXELS, 1),\n    testNumber('distance', options.distance ?? EXTRACTOR_DEFAULT.DISTANCE, 0, 1),\n    testUint('splitPower', options.splitPower ?? EXTRACTOR_DEFAULT.SPLIT_POWER, 2, 15),\n    testFunction('colorValidator', options.colorValidator ?? ((_red: number, _green: number, _blue: number, _alpha?: number) => (_alpha ?? 255) > 250)),\n    testNumber('hueDistance', options.hueDistance ?? AVERAGE_DEFAULT.HUE, 0, 1),\n    testNumber('saturationDistance', options.saturationDistance ?? AVERAGE_DEFAULT.LIGHTNESS, 0, 1),\n    testNumber('lightnessDistance', options.lightnessDistance ?? AVERAGE_DEFAULT.SATURATION, 0, 1),\n    (options as BrowserOptions).crossOrigin ?? null\n  ]\n}\n","import Color from './Color'\n\n/**\n * Manage list of colors to optimize and merge neighbors colors.\n *\n * @export\n * @class BudGroup\n */\nexport default class BudGroup {\n\n  _count: number\n  _children: { [key: number]: Color }\n  _maxWeight: number | undefined\n\n  /**\n   * Store colors or groups and _count similiar groups in the image.\n   */\n  constructor () {\n    this._count = 1\n    this._children = { }\n  }\n\n  /**\n   * Add color to the group.\n   */\n  addColor (_hex: number, _red: number, _green: number, _blue: number) {\n    if (this._children[_hex]) {\n      this._children[_hex]._count++\n    } else {\n      this._children[_hex] = new Color(_red, _green, _blue, _hex)\n    }\n\n    return this._children[_hex]\n  }\n\n  /**\n   * Get list of groups of list of colors.\n   */\n  getList () {\n    return (Object.keys(this._children) as unknown[] as number[])\n      .map((key) => this._children[key])\n  }\n\n  /**\n   * Max color weight between the list colors, depends of his saturation and his _count.\n   */\n   getMaxWeight (_count: number): number {\n    if (this._maxWeight === undefined) {\n      const list = this.getList()\n        .map((child) => child._count / _count)\n\n      list.sort((a, b) => b - a)\n      this._maxWeight = list[0] || 0\n    }\n\n    return this._maxWeight \n  }\n\n  /**\n   * Color with the the max weight between the list colors, depends of his saturation and his _count.\n   */\n  getMaxWeightColor (_count: number) {\n    const list = this.getList()\n    list.sort((a, b) => {\n      return (b._count / _count) - (a._count / _count)\n    })\n\n    return list[0]\n  }\n\n  /**\n   * Max _count of colors for a group of colors.\n   */\n  getMaxCountColor () {\n    const list = this.getList()\n    const biggest = list.reduce((a, b) => a._count >= b._count ? a : b)\n    return biggest\n  }\n}\n","import Color from './Color'\nimport BudGroup from './BudGroup'\n\n/**\n * RootGroup colors with algorithms to optimize and merge neighbors colors.\n * \n * @class\n * @classdesc Manage list of colors or groups.\n */\nexport default class RootGroup {\n  _count: number\n  _children: { [key: number]: RootGroup | BudGroup }\n  _maxWeight: number | undefined\n\n  /**\n   * Store colors or groups and _count similiar groups in the image.\n   */\n  constructor () {\n    this._count = 1\n    this._children = { }\n  }\n\n  /**\n   * Add a key for a color, this key is a simplification to find neighboring colors.\n   * Neighboring colors has same key.\n   */\n  addRootGroup (key: number) {\n    if (this._children[key]) {\n      this._children[key]._count++\n    } else {\n      this._children[key] = new RootGroup()\n    }\n\n    return this._children[key] as RootGroup\n  }\n\n  /**\n   * Get list of groups of list of colors.\n   */\n  getList () {\n    return (Object.keys(this._children) as unknown[] as number[])\n      .map((key) => this._children[key])\n  }\n\n  /**\n   * Add a key for a color, this key is a simplification to find neighboring colors.\n   * Neighboring colors has same key.\n   */\n   addBudGroup (key: number) {\n    if (this._children[key]) {\n      this._children[key]._count++\n    } else {\n      this._children[key] = new BudGroup()\n    }\n\n    return this._children[key] as BudGroup\n  }\n\n  /**\n   * Max color weight between the list colors, depends of his saturation and his _count.\n   */\n  getMaxWeight (_count: number): number {\n    if (this._maxWeight === undefined) {\n      const list = this.getList()\n        .map((child) => child._count / _count)\n\n      list.sort((a, b) => b - a)\n      this._maxWeight = list[0] || 0\n    }\n\n    return this._maxWeight \n  }\n\n  /**\n   * Color with the the max weight between the list colors, depends of his saturation and his _count.\n   */\n  getMaxWeightColor (_count: number): Color {\n    const list = this.getList()\n    list.sort((a, b) => {\n      return (b._count / _count) - (a._count / _count)\n    })\n\n    return list[0].getMaxWeightColor(_count)\n  }\n\n  /**\n   * Max _count of colors for a group of colors.\n   */\n  getMaxCountColor (): Color {\n    const list = this.getList()\n    const biggest = list.reduce((a, b) => a.getMaxCountColor()._count >= b.getMaxCountColor()._count ? a : b)\n    return biggest.getMaxCountColor()\n  }\n\n  /**\n   * List of colors sorted by importance (neighboring hare calculated by distance and removed).\n   * Importance is calculated with the saturation and _count of neighboring colors.\n   */\n  getColors (_distance: number, _count: number) {\n    const list = this.getList()\n      .map((child) => {\n        const { _count } = child\n        const color = child.getMaxCountColor()\n        color._count = _count\n        return color\n      })\n\n    list.sort((a, b) => (b._count / _count) - (a._count / _count))\n\n    const newList: Color[] = []\n    list.forEach((color) => {\n      const near = newList.find((col) => Color.distance(col, color) < _distance)\n      if (!near) {\n        newList.push(color)\n      } else {\n        near._count += color._count\n      }\n    })\n\n    return newList\n  }\n}\n","import RootGroup from '../color/RootGroup'\n\n/**\n * Run extract process and get list of colors.\n */\nexport default (\n  { data, width, height }: ImageData | { data: Uint8ClampedArray | number[], width?: number, height?: number },\n  _pixels: number,\n  _distance: number,\n  _splitPower: number,\n  _colorValidator: (red: number, green: number, blue: number, alpha: number) => boolean\n) => {\n  const rootGroup = new RootGroup()\n  const reducer = (width && height) ? Math.floor(width * height / _pixels) || 1 : 1\n  \n  for (let i = 0; i < data.length; i += 4 * reducer) {\n    const r = data[i] // 0 -> 255\n    const g = data[i + 1]\n    const b = data[i + 2]\n    const a = data[i + 3]\n\n    if (_colorValidator(r, g, b, a)) {\n      const real = r << 16 | g << 8 | b\n      const medium = (r >> 4 & 0xF) << 8 | (g >> 4 & 0xF) << 4 | (b >> 4 & 0xF)\n      const small = Math.round(r * (_splitPower - 1) / 255) * (_splitPower * _splitPower) + Math.round(g * (_splitPower - 1) / 255) * _splitPower + Math.round(b * (_splitPower - 1) / 255)\n\n      const smallGroup = rootGroup.addRootGroup(small)\n      const mediumGroup = smallGroup.addBudGroup(medium)\n      mediumGroup.addColor(real, r, g, b)\n    }\n  }\n  \n  return rootGroup.getColors(_distance, _pixels)\n}\n","import Color from \"./color/Color\"\nimport sortColors from \"./sort/sortColors\"\nimport { createFinalColor } from \"./color/FinalColor\"\nimport { BrowserOptions, NodeOptions } from \"./types/Options\"\nimport cleanInputs from \"./extract/cleanInputs\"\nimport extractor from \"./extract/extractor\"\n\n/**\n * Sort colors and generate standard list of colors.\n */\nexport const sortFinalColors = (_colors: Color[], _pixels: number, _hueDistance: number, _saturationDistance: number, _lightnessDistance: number) => {\n  const list = sortColors(_colors, _pixels, _hueDistance, _saturationDistance, _lightnessDistance)\n  return list.map(color => createFinalColor(color, _pixels))\n}\n\n/**\n * Extract colors from an ImageData object.\n */\nexport const extractColorsFromImageData = (imageData: ImageData | { data: Uint8ClampedArray | number[], width?: number, height?: number }, options: NodeOptions | BrowserOptions = {}) => {\n  const [_pixels, _distance, _splitPower, _colorValidator, _hueDistance, _saturationDistance, _lightnessDistance] = cleanInputs(options)\n  const colors = extractor(imageData, _pixels, _distance, _splitPower, _colorValidator)\n  const px = (imageData.width && imageData.height) ? Math.min(imageData.width * imageData.height, _pixels) : _pixels\n  return sortFinalColors(colors, px, _hueDistance, _saturationDistance, _lightnessDistance)\n}\n","import { extractColorsFromImageData } from './extractColors'\nimport { FinalColor } from './types/Color'\nimport type { NodeOptions } from \"./types/Options\"\n\n/**\n * Extract colors from an imageData.\n */\nconst extractColors = (imageData: ImageData | { data: Uint8ClampedArray | number[], width?: number, height?: number }, options?: NodeOptions) => {\n  if (imageData.data) {\n    return new Promise((resolve: (value: FinalColor[]) => void) => {\n      resolve(extractColorsFromImageData(imageData, options))\n    })\n  }\n\n  throw new Error('Send imageData to extractColors')\n}\n\nconst extractColorsFromImage = () => {\n  throw new Error('Can not use extractColorsFromImage for Node.js')\n}\n\nconst extractColorsFromSrc = () => {\n  throw new Error('Can not use extractColorsFromSrc for Node.js')\n}\n\nexport {\n  extractColorsFromImageData,\n  extractColorsFromImage,\n  extractColorsFromSrc,\n  extractColors\n}\n\nexport default extractColors\n"],"names":["distance","total","_count"],"mappings":"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"}